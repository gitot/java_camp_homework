# 作业说明


### 使用G1收集器启动程序，然后使用工具分析内存情况
本地启动 gateway-server-0.0.1-SNAPSHOT.jar jar程序，使用如下命令启动。

`
java -XX:+UseG1GC -jar gateway-server-0.0.1-SNAPSHOT.jar
`

使用jmap,在mac无法使用。 降级使用'kill -3 pid' 分析jvm进程堆栈信息。
然后使用了jstack，dump了堆栈信息。
jconsole，查看了jvm的各个方面的运行状况。

### gc与堆内存总结

#### gc垃圾收集器
Serial 收集器是单线程的收集器。适用于一些客户端的系统，在服务端很少使用。因为它使用单线程进行垃圾收集，
所以垃圾收集的效率不高，gc的次数频繁，而且没有垃圾回收的时间也比较长。

Parallel 收集器是堆Serial收集器的改进，基于多线程，是一款吞吐量优先的收集器，主要是为了降低整体的gc时间。

CMS是老年代的收集器，侧重于降低gc停顿时间。它将gc的过程进行拆分，只在部分阶段需要STW,其他时间与业务线程并发。

g1是对cms的改进，可以通过vm参数指定gc的最大停顿时间。它将内存区域划分为一个个小的内存区域（Region）,每次回收时只对其中部分的Region进行回收。
此时依然有内存年代的划分，只不过是每个年代区域的大小和位置是动态的（每一个Region属于哪个年代是动态调整的）。

g1因为对内存的划分方式不同，在gc日志上，可以看出明显的不同（也更加复杂）。

#### 内存的配置

内存的大小配置（Xms,Xmx）最佳实践是现实的配置，并且Xms=Xmx. 
如果不显示配置内存，一般Xms是小于Xmx的。如此当当前堆内存不够的时候，就会触发一次内存扩容， 
这就导致了在少数情况下系统延迟增大。
因此，索性程序启动的时候就分配好内存的大小，避免运行器动态扩容。

内存的配置存在蓄水池效应。
内存大小加大可以减少gc的次数，但是一旦发生gc就会产生较大的停顿时间。

